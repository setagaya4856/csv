<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Supabase Edge Function テスト</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- ▼ Handsontable（CDN） -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.css">
<script src="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.js"></script>

  <style>
    /* 折り返しをやめて、縮小＋省略で表示 */
    .htCore td {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1.2;
      vertical-align: middle; /* ★ 追加 */
    }
    body{
      font-family:system-ui, sans-serif;
      /* 画面の95%まで広げる（上限もかけておく場合は 1200px などに調整可） */
      width:95vw;
      margin:24px auto;
      padding:0 12px;
    }
    fieldset{margin:12px 0; padding:12px;}
    label{display:block; margin:6px 0 2px;}
    input{padding:6px; width:100%; max-width:360px;}
    button{margin:6px 6px 0 0; padding:6px 12px;}
    pre{background:#f6f8fa; padding:12px; border-radius:6px; overflow:auto;}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
  .ht-today  { background:#fff9db !important; }  /* 今日: 薄い黄 */
  .ht-sat    { background:#e6ffed !important; }  /* 土曜: 緑 */
  .ht-sun    { background:#ffe5e5 !important; }  /* 日曜: ピンク */
  .ht-holiday{ background:#ffe5e5 !important; }  /* 「休」含む: ピンク */
  .tabs{display:flex;gap:6px;margin:8px 0 12px}
  .tabs button{padding:6px 10px;border:1px solid #ccc;background:#f6f6f6;cursor:pointer;border-radius:6px}
  .tabs button.active{background:#fff;border-color:#999;font-weight:600;box-shadow:0 1px 0 #ddd}
    /* ★ 自分の行の強調（太枠） */
.my-row {
  outline: 2px solid #333 !important;
  outline-offset: -1px;
}

/* ★ department 色バケット（8色） */
.dep-1  { background: #fff7e6 !important; } /* orange-ish */
.dep-2  { background: #e6f7ff !important; } /* blue-ish */
.dep-3  { background: #f9f0ff !important; } /* purple-ish */
.dep-4  { background: #e6fffb !important; } /* cyan-ish */
.dep-5  { background: #f6ffed !important; } /* green-ish */
.dep-6  { background: #fff1f0 !important; } /* red-ish */
.dep-7  { background: #f0f5ff !important; } /* indigo-ish */
.dep-8  { background: #fefefe !important; } /* neutral */

.name-note { font-size: 0.85em; color:#666; white-space: pre-wrap; }
    .hot-btn {
  padding: 4px 10px;
  border: 1px solid #bbb;
  border-radius: 6px;
  background: #fff;
  cursor: pointer;
}
.hot-btn:hover { background: #f6f6f6; }
  </style>
</head>
<body>
  <h1>Supabase Edge Function テスト</h1>

  <fieldset>
    <legend>設定</legend>
    <div class="row">
      <label>SUPABASE_URL</label>
      <input id="url" placeholder="https://rqrgsytkxbhbrnrhqlca.supabase.co" />
    </div>
    <div class="row">
      <label>ANON_KEY</label>
      <input id="anon" placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJxcmdzeXRreGJoYnJucmhxbGNhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU2ODIyODMsImV4cCI6MjA3MTI1ODI4M30.LWeiva7gpFf9lHGuOKqzyr-tZihHuX9KdlHUjuqYDU0" />
    </div>
    <button id="init">Supabase 初期化</button>
  </fieldset>

  <fieldset>
    <legend>ログイン</legend>
    <label>メールアドレス</label>
    <input id="email" type="email" placeholder="you@example.com" />
    <label>パスワード（パスワード方式で使う場合）</label>
    <input id="password" type="password" placeholder="8文字以上" />
    <div class="row">
      <button id="login-pw">メール＋パスワードでログイン</button>
      <button id="signup-pw">（初回）メール＋パスワードでサインアップ</button>
      <button id="login-otp">マジックリンク送信（メールOTP）</button>
      <button id="logout">ログアウト</button>
    </div>
    <div id="who" style="margin-top:6px;color:#333;"></div>
  </fieldset>

  <fieldset>
    <legend>関数呼び出し</legend>
    <button id="run">/functions/v1/schedules-get を叩く</button>
    <pre id="output">ここに結果が出ます</pre>
    <div id="sched-summary" style="margin:12px 0;color:#555;"></div>
    <h3 style="margin:8px 0">クイック登録</h3>
    <div id="quickEntry" style="max-width:720px; margin:6px 0 12px;"></div>
    <div id="month-tabs" class="tabs"></div>
    <div class="row" style="gap:12px; width:100%; margin:0 auto;">
      <div style="flex:1 1 380px;min-width:320px">
        <h2 style="margin:8px 0">スケジュール一覧</h2>
        <div id="sched-list"></div>
      </div>
    </div>

    <h2 style="margin:16px 0 8px">従業員 × 日付 マトリクス</h2>
    <div id="matrixGrid" style="height:520px;width:100%;"></div>
  </fieldset>

  <script type="module">
    let hotQuick = null;

// きょうの YYYY-MM-DD を返す（JST）
function todayYYYYMMDD() {
  const dt = todayJST();
  const y = dt.getFullYear();
  const m = String(dt.getMonth() + 1).padStart(2, '0');
  const d = String(dt.getDate()).padStart(2, '0');
  return `${y}-${m}-${d}`;
}

// Handsontable のカラム: 登録ボタン用レンダラー
function buttonRenderer(instance, td, row, col, prop, value, cellProperties) {
  td.innerHTML = '';
  const btn = document.createElement('button');
  btn.className = 'hot-btn';
  btn.textContent = '登録';
  btn.addEventListener('click', () => {
    const r = instance.getDataAtRow(row);
    // r[0]=日付, r[1]=午前, r[2]=午後
    const payload = {
      date: (r[0] || '').trim(),
      am: (r[1] || '').trim(),
      pm: (r[2] || '').trim(),
    };
    handleQuickSave(payload); // 後述のハンドラに渡す
  });
  td.appendChild(btn);
}

// 入力バリデーション（YYYY-MM-DD）
function isValidDateYYYYMMDD(s) {
  if (!/^\d{4}-\d{2}-\d{2}$/.test(s)) return false;
  const d = new Date(s + 'T00:00:00');
  return !Number.isNaN(d.getTime()) && s === `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
}

// クイック登録用 HOT を描画
function renderQuickEntryHot() {
  const container = document.getElementById('quickEntry');
  if (!container) return;

  const data = [
    [todayYYYYMMDD(), '', '']  // 1行だけ（必要なら複数行に増やせる）
  ];

  const settings = {
    data,
    colHeaders: ['日付 (YYYY-MM-DD)', '午前（テキスト）', '午後（テキスト）', ''],
    columns: [
      { type: 'text', width: 150 },
      { type: 'text', width: 220 },
      { type: 'text', width: 220 },
      { renderer: buttonRenderer, readOnly: true, width: 90 },
    ],
    rowHeaders: false,
    stretchH: 'all',
    height: 48 + 2, // 1行ぶん
    licenseKey: 'non-commercial-and-evaluation',
    contextMenu: false,
    manualColumnResize: true,
    manualRowResize: false,
    enterMoves: (e) => (e && e.shiftKey ? { row: 0, col: -1 } : { row: 0, col: 1 }),
    afterChange: (changes, source) => {
      if (!changes || source !== 'edit') return;
      for (const [row, col, oldVal, newVal] of changes) {
        if (col === 0 && newVal != null && newVal !== '' && !isValidDateYYYYMMDD(String(newVal))) {
          // 日付の軽いバリデーション
          setTimeout(() => alert('日付は YYYY-MM-DD 形式で入力してください'), 0);
        }
      }
    },
    cells: () => ({ renderer: fitTextRenderer }), // 既存の縮小レンダラーを流用してOK
  };

  if (hotQuick) {
    hotQuick.updateSettings(settings);
  } else {
    hotQuick = new Handsontable(container, settings);
  }
}
    // ===== テキスト幅に応じてフォントサイズを縮小するレンダラー =====
const _measureCanvas = document.createElement('canvas');
const _ctx = _measureCanvas.getContext('2d');

function measureTextWidth(text, font) {
  _ctx.font = font;
  return _ctx.measureText(text).width;
}

function fitTextRenderer(instance, td, row, col, prop, value, cellProperties) {
  // 既定のテキスト描画
  Handsontable.renderers.TextRenderer.apply(this, arguments);

  // 折り返しオフ＋省略
  td.style.whiteSpace = 'nowrap';
  td.style.overflow = 'hidden';
  td.style.textOverflow = 'ellipsis';

  // 表示文字列（改行は1行にまとめる）
  const raw = (value == null ? '' : String(value));
  const show = raw.replace(/\r?\n/g, ' / ');

  // 基準フォントサイズと最小フォントサイズ
  const basePx = 14;     // 好みで調整
  const minPx  = 10;     // 下限
  let fontPx = basePx;

  // セルの横幅（余白分を差し引く）
  const padding = 14; // 左右の内余白相当
  const colWidth = (instance.getColWidth(col) || td.clientWidth || 100) - padding;

  // 現在のフォント（太字やクラスがある前提は簡易化）
  const fontFamily = getComputedStyle(td).fontFamily || 'system-ui,sans-serif';
  const fontWeight = getComputedStyle(td).fontWeight || 'normal';

  // 収まるまでフォントサイズを下げる（簡易）
  while (fontPx > minPx) {
    const font = `${fontWeight} ${fontPx}px ${fontFamily}`;
    const w = measureTextWidth(show, font);
    if (w <= colWidth) break;
    fontPx -= 1;
  }
  td.style.fontSize = `${fontPx}px`;

  // cell の実テキストを差し替える（1行化）
  td.textContent = show;
}
    // ===== 従業員メタ & 権限 =====
let currentUser = { email: null, employee_id: null, is_admin: false };
let employeesAll = []; // [{id,name,email,department,note,row_index,is_admin}, ...]

async function loadCurrentUserAndEmployees() {
  // 1) ログインユーザー
  const { data: { session } } = await supabase.auth.getSession();
  const email = session?.user?.email ?? null;

  // 2) 従業員一覧（全員）
  const { data: emps, error } = await supabase
    .from('employees')
    .select('id,name,email,department,note,row_index,is_admin')
    .order('row_index', { ascending: true })
    .order('name', { ascending: true });

  if (error) throw error;

  employeesAll = emps ?? [];

  // 3) 自分の従業員レコード & 権限
  const me = employeesAll.find(e => (e.email || '').toLowerCase() === (email || '').toLowerCase());
  currentUser = {
    email,
    employee_id: me?.id ?? null,
    is_admin: !!me?.is_admin
  };
}

// 部署文字列→安定色バケット（1..8）
function bucketByDepartment(dep) {
  const s = String(dep || '');
  let h = 0; for (let i=0;i<s.length;i++) h = (h*31 + s.charCodeAt(i)) >>> 0;
  return (h % 8) + 1;
}
    import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
    let supabase = null;

    const $ = (q) => document.querySelector(q);
    const out = $('#output');
    const who = $('#who');
    function enableHorizontalWheel(container, hot) {
  // 多重登録防止
  if (container.dataset.hwBound === '1') return;
  container.dataset.hwBound = '1';

  const holder = container.querySelector('.ht_master .wtHolder');
  if (!holder) return;

  holder.addEventListener('wheel', (e) => {
    // セル選択がある時だけ横スクロールに変換
    const hasSelection = !!hot?.getSelectedRangeLast?.();
    if (!hasSelection) return;

    // 縦スクロール量を横スクロールへ
    if (Math.abs(e.deltaY) >= Math.abs(e.deltaX)) {
      holder.scrollLeft += e.deltaY; // 下(+)→右 / 上(-)→左
      e.preventDefault();            // 既定の縦スクロールを止める
    }
  }, { passive: false });
}
// ==== タブ＆月ユーティリティ ====
// 月キャッシュ: Map<"YYYY-MM", Array<item>>
const monthCache = new Map();

function ymOf(d){
  return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
}
function monthsAround(baseDate, back=3, forward=3){
  const list = [];
  const d = new Date(baseDate.getFullYear(), baseDate.getMonth()-back, 1);
  const end = new Date(baseDate.getFullYear(), baseDate.getMonth()+forward+1, 1);
  while (d < end){
    list.push(ymOf(d));
    d.setMonth(d.getMonth()+1, 1);
  }
  return list; // 昇順、計 back+forward+1 個
}
function todayJST(){
  const now = new Date();
  return new Date(now.getTime() + (9*60 + now.getTimezoneOffset())*60000);
}
    function buildMonthTabs() {
  const base = todayJST();
  const months = monthsAround(base, 3, 3);
  const todayYm = ymOf(base);
  const wrap = document.getElementById('month-tabs');
  wrap.innerHTML = '';
  for (const ym of months) {
    const btn = document.createElement('button');
    btn.textContent = ym;
    btn.dataset.month = ym;
    if (ym === todayYm) btn.classList.add('active');
    btn.addEventListener('click', () => onMonthTabClick(btn));
    wrap.appendChild(btn);
  }
  return { months, todayYm };
}
async function handleQuickSave({ date, am, pm }) {
  if (!date || !isValidDateYYYYMMDD(date)) {
    alert('日付は YYYY-MM-DD で入力してください');
    return;
  }
  // ここでは UI だけ先につくるので、ひとまずログ出力
  out.textContent = `クイック登録 受信: date=${date} / AM="${am}" / PM="${pm}"`;
  // このあと実装予定：
  //   - ログインユーザーから従業員IDを確定（email → employees.id）
  //   - Edge Function /functions/v1/schedules-upsert に POST（am/pm それぞれ）
  //   - 成功したら、対象の月を再読込して表を更新
}
async function onMonthTabClick(btn){
  // active切替
  document.querySelectorAll('#month-tabs button').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  const ym = btn.dataset.month;
  // 今月なら今日AMへスクロール、他の月は固定（1日AM）
  const isThisMonth = ym === ymOf(todayJST());
  await loadMonth(ym, { scrollToToday: isThisMonth });
}
    async function fetchMonthData(ym, token, url){
  // すでにキャッシュあればそれを返す
  if (monthCache.has(ym)) return monthCache.get(ym);

  const res = await fetch(`${url}/functions/v1/schedules-get?month=${encodeURIComponent(ym)}`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  const json = await res.json();
  const items = normalizeSchedules(json);
  monthCache.set(ym, items);
  return items;
}

async function loadMonth(ym, { scrollToToday } = { scrollToToday:false }) {
  if (!supabase) return alert('先に「Supabase 初期化」を押してください');
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) { out.textContent = '未ログインです'; return; }
  const token = session.access_token;
  const url = $('#url').value.trim();

  out.textContent = `読み込み中... (${ym})`;
  try{
    const items = await fetchMonthData(ym, token, url);
    out.textContent = `OK: ${ym} / ${items.length}件`;
    // 一覧＆マトリクスを月単位で描画
    renderSchedules(items, ym);        // ← 既存のまま（内部で month で絞る）
    renderMatrixHot(items, ym, { scrollToToday }); // ← 次の手順で対応
  }catch(e){
    out.textContent = 'Fetchエラー: ' + e.message;
  }
}

    function setUser(u){
      who.textContent = u ? `ログイン中: ${u.email}` : '未ログイン';
    }

    // 初期化
    $('#init').addEventListener('click', () => {
      const url = $('#url').value.trim();
      const anon = $('#anon').value.trim();
      if (!url || !anon) { alert('SUPABASE_URL と ANON_KEY を入れてください'); return; }
      supabase = createClient(url, anon);
      out.textContent = 'Supabase 初期化完了';
      supabase.auth.getSession().then(({ data: { session }}) => setUser(session?.user ?? null));
      supabase.auth.onAuthStateChange((evt, session) => setUser(session?.user ?? null));
    });

    // パスワードでログイン
    $('#login-pw').addEventListener('click', async () => {
      if (!supabase) return alert('先に「Supabase 初期化」を押してください');
      const email = $('#email').value.trim();
      const password = $('#password').value;
      out.textContent = 'ログイン中...';
      const { data, error } = await supabase.auth.signInWithPassword({ email, password });
      if (error) out.textContent = 'エラー: ' + error.message;
      else out.textContent = 'ログイン成功';
      setUser(data.user);
    });

    // パスワードでサインアップ
    $('#signup-pw').addEventListener('click', async () => {
      if (!supabase) return alert('先に「Supーム゙ース 初期化」を押してください');
      const email = $('#email').value.trim();
      const password = $('#password').value;
      out.textContent = 'サインアップ中...';
      const { data, error } = await supabase.auth.signUp({ email, password,
        options: { emailRedirectTo: 'https://setagaya4856.github.io/csv/schedules/' }
      });
      if (error) out.textContent = 'エラー: ' + error.message;
      else out.textContent = 'サインアップ完了。メールの確認が必要な場合があります。';
      setUser(data.user);
    });

    // マジックリンク（OTP）
    $('#login-otp').addEventListener('click', async () => {
      if (!supabase) return alert('先に「Supabase 初期化」を押してください');
      const email = $('#email').value.trim();
      out.textContent = 'マジックリンク送信中...';
      const { error } = await supabase.auth.signInWithOtp({
        email,
        options: { emailRedirectTo: location.origin }
      });
      out.textContent = error ? ('エラー: ' + error.message) : 'メールを確認してリンクを開いてください';
    });

    // ログアウト
    $('#logout').addEventListener('click', async () => {
      if (!supabase) return alert('先に「Supabase 初期化」を押してください');
      await supabase.auth.signOut();
      setUser(null);
      out.textContent = 'ログアウトしました';
    });


// ====== 初期化（タブ生成→今日の月を表示） ======
$('#run').addEventListener('click', async () => {
  const { todayYm } = (() => {
    const { months, todayYm } = buildMonthTabs();
    return { todayYm };
  })();

  if (!supabase) return alert('先に「Supabase 初期化」を押してください');

  try {
    // 1) クイック登録ミニ表を先に表示（従業員情報なしでも出せる）
    renderQuickEntryHot();
    out.textContent = '従業員情報を取得中...';
    await loadCurrentUserAndEmployees(); // ★ 先に従業員＆自分の権限をロード
    await loadMonth(todayYm, { scrollToToday: true });
  } catch (e) {
    out.textContent = '従業員取得エラー: ' + e.message;
  }
});
// 2D配列 → TSV
const tsvFrom2D = (arr) =>
  arr.map(row => row.map(v => (v == null ? '' : String(v))).join('\t')).join('\n');

const getSelectionBounds = (hot) => {
  const rng = hot.getSelectedRangeLast?.();
  if (!rng) return null;
  const r1 = Math.min(rng.from.row, rng.to.row);
  const r2 = Math.max(rng.from.row, rng.to.row);
  const c1 = Math.min(rng.from.col, rng.to.col);
  const c2 = Math.max(rng.from.col, rng.to.col);
  return { r1, r2, c1, c2 };
};

async function copySelection(hot) {
  const b = getSelectionBounds(hot);
  if (!b) return;
  const data = hot.getData(b.r1, b.c1, b.r2, b.c2);
  await navigator.clipboard.writeText(tsvFrom2D(data));
}

async function cutSelection(hot) {
  const b = getSelectionBounds(hot);
  if (!b) return;
  const data = hot.getData(b.r1, b.c1, b.r2, b.c2);
  await navigator.clipboard.writeText(tsvFrom2D(data));
  // 空文字でクリア
  for (let r = b.r1; r <= b.r2; r++) {
    for (let c = b.c1; c <= b.c2; c++) hot.setDataAtCell(r, c, '');
  }
}

async function pasteFromClipboard(hot) {
  const text = await navigator.clipboard.readText();
  if (!text) return;

  const rows = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n')
                   .split('\n').map(line => line.split('\t'));

  const rng = hot.getSelectedRangeLast?.();
  if (!rng) { alert('貼り付け先のセルを選択してください'); return; }

  const startRow = Math.min(rng.from.row, rng.to.row);
  const startCol = Math.min(rng.from.col, rng.to.col);
  const endRow   = startRow + rows.length - 1;
  const endCol   = startCol + (rows[0]?.length ?? 1) - 1;

  // ★ readOnly を含むなら中止
  if (containsReadOnlyInRange(hot, startRow, startCol, endRow, endCol)) {
    alert('貼り付け先に読み取り専用セルが含まれているため、貼り付けできません。');
    return;
  }

  // 貼り付け実行
  rows.forEach((r, i) => r.forEach((val, j) => {
    hot.setDataAtCell(startRow + i, startCol + j, val);
  }));
}
    
function containsReadOnlyInRange(hot, r1, c1, r2, c2) {
  for (let r = r1; r <= r2; r++) {
    for (let c = c1; c <= c2; c++) {
      if (hot.getCellMeta(r, c)?.readOnly) return true;
    }
  }
  return false;
}
    // ====== マトリクス（Handsontable） ======
    // 既存 buildMatrix を活かしつつ、2次元配列に詰め替え
    function extractEmployeeName(item) {
      const r = item.raw || {};
      return item.employee_name || r.employee_name || r.employee || r.user || r.name || r.assignee || '（未割当）';
    }
    function buildMatrixAmPm(items, ym) {
  const [y, m] = ym.split('-').map(Number);
  const last = new Date(y, m, 0);
  const days = Array.from({ length: last.getDate() }, (_, i) => i + 1);

  const byEmp = new Map();
  for (const it of items) {
    const emp = extractEmployeeName(it);
    if (!byEmp.has(emp)) byEmp.set(emp, {});
    const d = it.baseDate.getDate();
    if (!byEmp.get(emp)[d]) byEmp.get(emp)[d] = { am: [], pm: [] };
    const hour = it.start?.getHours() ?? 0;
    const key = hour < 12 ? 'am' : 'pm';
    byEmp.get(emp)[d][key].push(it);
  }

  const data = [];
  for (const [emp, perDay] of byEmp) {
    const row = [emp];
    for (const d of days) {
      const arrAm = perDay[d]?.am || [];
      const arrPm = perDay[d]?.pm || [];
      row.push(arrAm.map(a => a.title).join('\n')); // 午前
      row.push(arrPm.map(a => a.title).join('\n')); // 午後
    }
    data.push(row);
  }

  const colHeaders = ['名前'];
  // 各列がどの日付かを保存（0列目は名前なので null）
  const colDates = [null];
  for (const d of days) {
    const ds = `${y}-${String(m).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
    colHeaders.push(`${m}/${d} 午前`);
    colHeaders.push(`${m}/${d} 午後`);
    colDates.push(ds, ds); // 午前・午後とも同じ日付
  }

  return { colHeaders, data, colDates };
}

    // ★ 従業員フルリストと月のスケジュール(items)から "必ず全従業員を出す" マトリクスを作る
function buildFullMatrixWithEmployees(items, ym) {
  const [y, m] = ym.split('-').map(Number);
  const last = new Date(y, m, 0);
  const days = Array.from({ length: last.getDate() }, (_, i) => i + 1);

  // 1) 既存 items を (employee_name or email or id) → {day→{am/pm}} に集約
  // items は normalizeSchedules(json)の戻り。json.rows 由来なら raw に row情報が入っている。
  const byEmpKey = new Map(); // key: employee_id など、value: { name, email, department, note, cells: {d: {am,pm}} }
  for (const it of items) {
    // 従業員IDを raw から拾えるよう、Edge側で rows[*] に employee_id, email, department, note を入れておくのがベスト
    const row = it.raw || {};
    const empId = row.employee_id || row.id || row.emp_id || null;
    // フォールバックで名前突合も一応残す
    const name = it.employee_name || row.employee_name || row.name || '（未割当）';
    const email = row.email || '';
    const dep = row.department || '';
    const note = row.note || '';

    const key = empId ?? `name:${name}`; // なるべく id を key に使う
    if (!byEmpKey.has(key)) byEmpKey.set(key, { employee_id: empId, name, email, department: dep, note, cells: {} });

    const d = it.baseDate.getDate();
    if (!byEmpKey.get(key).cells[d]) byEmpKey.get(key).cells[d] = { am: [], pm: [] };

    const hour = it.start?.getHours() ?? 0;
    const slot = hour < 12 ? 'am' : 'pm';
    byEmpKey.get(key).cells[d][slot].push(it.title);
  }

  // 2) 従業員フルリストを基準に "なければ空行" を作る
  // employeesAll: [{id,name,email,department,note,row_index,is_admin}]
  const rowsMeta = employeesAll.slice().sort((a,b)=>(a.row_index ?? 0)-(b.row_index ?? 0) || a.name.localeCompare(b.name,'ja'));

  // Handsontable 表示用データ
  const data = [];
  const rowEmployees = []; // 各行に対応する従業員メタ
  const colHeaders = ['名前', 'メモ'];   // ★ ノート列を追加
  const colDates = [null, null];          // ★ 2列分は日付なし
  for (const d of days) {
    colHeaders.push(`${m}/${d} 午前`);
    colHeaders.push(`${m}/${d} 午後`);
    const ds = `${y}-${String(m).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
    colDates.push(ds, ds);
  }

  for (const emp of rowsMeta) {
    // 既存スケジュールがあるなら拾い、無ければ空
    const key = emp.id ?? `name:${emp.name}`;
    const agg = byEmpKey.get(key);
    const row = [];

    row.push(emp.name);           // 名前列
    row.push(emp.note || '');     // ★ ノート列（固定列2列目）

    // 各日 AM/PM
    for (const d of days) {
      const am = agg?.cells?.[d]?.am?.join('\n') ?? '';
      const pm = agg?.cells?.[d]?.pm?.join('\n') ?? '';
      row.push(am);
      row.push(pm);
    }

    data.push(row);
    rowEmployees.push({
      id: emp.id,
      name: emp.name,
      email: emp.email,
      department: emp.department,
      note: emp.note,
      is_admin: !!emp.is_admin
    });
  }

  return { colHeaders, data, colDates, rowEmployees };
}

// ==== 条件付き書式ルール群 ====
// 追加：クラスを結合するユーティリティ
function mergeClass(existing, add) {
  const arr = Array.isArray(add) ? add : [add];
  const set = new Set(String(existing || '').split(' ').filter(Boolean));
  for (const c of arr) if (c) set.add(c);
  return Array.from(set).join(' ');
}
    
// JST 今日 (YYYY-MM-DD) はそのまま（Intlで安定）
function todayStrJST() {
  const dt = new Date();
  const f = new Intl.DateTimeFormat('ja-JP', {
    timeZone: 'Asia/Tokyo',
    year: 'numeric', month: '2-digit', day: '2-digit'
  });
  const parts = Object.fromEntries(f.formatToParts(dt).map(p => [p.type, p.value]));
  return `${parts.year}-${parts.month}-${parts.day}`;
}
    
// ★置き換え：曜日/今日の色付け（タイムゾーンに依らない）
function classesByDate(ds, today) {
  if (!ds) return [];
  const [y, m, d] = ds.split('-').map(Number);
  const wd = weekdayOf(y, m, d); // 0=Sun ... 6=Sat
  const classes = [];
  if (ds === today) classes.push('ht-today');
  if (wd === 6) classes.push('ht-sat');
  if (wd === 0) classes.push('ht-sun');
  return classes;
}
    
// 0=Sun,1=Mon,...6=Sat を返す（タイムゾーン非依存）
function weekdayOf(y, m, d) {
  // Tomohiko Sakamoto’s algorithm
  const t = [0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4];
  if (m < 3) y -= 1;
  return (y + Math.floor(y/4) - Math.floor(y/100) + Math.floor(y/400) + t[m-1] + d) % 7;
}
// 値に応じたクラス（内容に「休」を含む）
function classesByValue(value) {
  const v = String(value ?? '');
  return v.includes('休') ? ['ht-holiday'] : [];
}

// afterChange 用: 値で変わるクラス（ht-holiday）だけ付け外しする
function applyValueRule(hot, row, col, value) {
  if (col === 0) return; // 名前列は対象外
  const meta = hot.getCellMeta(row, col);
  const keep = (meta.className || '')
    .split(' ')
    .filter(Boolean)
    // 日付ベースの色は維持、値ベースの 'ht-holiday' だけ付け外し
    .filter(c => c !== 'ht-holiday');

  const add = classesByValue(value);
  const next = keep.concat(add);
  hot.setCellMeta(row, col, 'className', next.join(' '));
}
  function stripDateClasses(className) {
  return String(className || '')
    .split(/\s+/)
    .filter(c => c && c !== 'ht-today' && c !== 'ht-sat' && c !== 'ht-sun')
    .join(' ');
}
// ★固定列を考慮しつつ、目的列を左端にピタッと合わせる
function scrollColumnToLeft(hot, container, colIndex) {
  const holder = container.querySelector('.ht_master .wtHolder');
  if (!holder) return;

  const fixed = hot.getSettings().fixedColumnsStart || 0;

  // まず、目的列がDOMに描画されるように可視領域へスクロール
  hot.scrollViewportTo(0, colIndex);

  // 描画が落ち着いた後に“幅の総和”でスクロール量を決定
  requestAnimationFrame(() => {
    let offset = 0;
    // master側は fixedColumnsStart 以降がスクロール対象
    // → 左固定列の幅は除外し、[fixed .. colIndex-1] の幅を積算
    for (let c = fixed; c < colIndex; c++) {
      offset += hot.getColWidth(c) || 0;
    }
    // ほんの少し余白（任意）
    holder.scrollLeft = Math.max(0, offset - 4);
  });
}
    // ★ 自分の行かどうか（太枠用、編集可否とは独立）
const isMyRow = (rowIdx, rowEmployees, currentUser) => {
  const emp = rowEmployees[rowIdx];
  if (!emp || !currentUser?.email) return false;
  return (emp.email || '').toLowerCase() === currentUser.email.toLowerCase();
};
    let hot = null;
  function renderMatrixHot(items, ym, opts = {}) {
  const { colHeaders, data, colDates, rowEmployees } = buildFullMatrixWithEmployees(items, ym);
  const container = document.getElementById('matrixGrid');
  const maxRows = data.length;
  const maxCols = colHeaders.length;
  const today = todayStrJST();

  // ★ 編集可否の判定（自分 or 管理者）
  const canEditRow = (rowIdx) => {
    if (currentUser.is_admin) return true;
    const emp = rowEmployees[rowIdx];
    if (!emp) return false;
    return (currentUser.email && emp.email && currentUser.email.toLowerCase() === emp.email.toLowerCase());
  };
    
  const settings = {
    data,
    colHeaders,
    rowHeaders: true,
    licenseKey: 'non-commercial-and-evaluation',
    fixedColumnsStart: 2,
    // Enterで右/Shift+Enterで左へ
    enterMoves: (e) => (e && e.shiftKey ? { row: 0, col: -1 } : { row: 0, col: 1 }),
    // 全セルに縮小レンダラーを適用
    cells: (row, col) => ({ renderer: fitTextRenderer }),
    // ① 右クリックはコピー/切り取り/貼り付け/Undo/Redo のみ（既存）
    contextMenu: {
      items: {
        copyCustom: {
          name: 'コピー',
          callback: () => copySelection(hot),
          disabled: () => !hot.getSelectedRangeLast?.() || !navigator.clipboard?.writeText
        },
        cutCustom: {
          name: '切り取り',
          callback: () => cutSelection(hot),
          disabled: () => !hot.getSelectedRangeLast?.() || !navigator.clipboard?.writeText
        },
        pasteCustom: {
          name: '貼り付け',
          callback: () => pasteFromClipboard(hot),
          disabled: () => !navigator.clipboard?.readText
        },
        '--------': Handsontable.plugins.ContextMenu.SEPARATOR,
        undo: { name: '元に戻す' },
        redo: { name: 'やり直す' },
      }
    },
    maxRows,
    maxCols,
    fillHandle: { autoInsertRow: false },
    copyPaste: true,
    selectionMode: 'multiple',
    beforeCreateRow: () => false,
    beforeRemoveRow: () => false,
    beforeCreateCol: () => false,
    beforeRemoveCol: () => false,
    beforePaste: (data, coords) => {
      for (const sel of coords || []) {
        const { startRow, startCol, endRow, endCol } = sel;
        // ★ 貼り付け先が編集不可行を含むなら拒否
        for (let r = startRow; r <= endRow; r++) {
          if (!canEditRow(r)) return false;
        }
        if (containsReadOnlyInRange(hot, startRow, startCol, endRow, endCol)) {
          alert('貼り付け先に読み取り専用セルが含まれているため、貼り付けできません。');
          return false;
        }
      }
    },
    
    afterGetCellMeta: (row, col, props) => {
      const ds = colDates[col]; // YYYY-MM-DD (1列目は null)
      const emp = rowEmployees[row];

      // 1列目（名前）は常に readOnly。部署色＋ノート表示用のクラス付与
      if (col === 0　|| col === 1) {
        const bucket = bucketByDepartment(emp?.department);
        props.className = mergeClass(props.className, `dep-${bucket}`);        
        if (col === 0) {
          props.readOnly = true;
        }
        // ★ 太枠は「自分の行」だけ（管理者でも全行太枠にはしない）
        if (isMyRow(row, rowEmployees, currentUser)) {
          props.className = mergeClass(props.className, 'my-row');
        }
        return;
      }

      // 日付ベースの色（今日/土日）
      props.className = stripDateClasses(props.className);
      if (ds) {
        const add = classesByDate(ds, today);
        props.className = mergeClass(props.className, add);
      }

      // 値によるハイライト（「休」）
      // → 値変更時は afterChange で別途付け外し（既存）

      // ★ 編集可否：自分の行だけ編集可（管理者は全行可）
      props.readOnly = !canEditRow(row);
      // ★ 太枠は「自分の行」だけ
      if (isMyRow(row, rowEmployees, currentUser)) {
        props.className = mergeClass(props.className, 'my-row');
      }
    },


    // ▼ 条件付き書式：値（「休」）で決まるクラス
    afterChange: (changes, source) => {
      if (!changes) return;
      for (const [row, col, _oldVal, newVal] of changes) {
        applyValueRule(hot, row, col, newVal);
      }
      hot.render();
    },

    stretchH: 'all',
    height: 520,
    // ★ 列幅調整：名前=180 / メモ=180 / 以降=110
    colWidths: (index) => (index === 0 ? 110 : index === 1 ? 180 : 110),
  };

  const wasInit = !!hot;
  if (hot) {
    hot.updateSettings(settings);
    hot.render();
  } else {
    hot = new Handsontable(container, settings);
  }

  // 初期データにも値ベースのクラス（ht-holiday）を一括適用
  for (let r = 0; r < data.length; r++) {
    for (let c = 1; c < colHeaders.length; c++) {
      applyValueRule(hot, r, c, data[r][c]);
    }
  }
  hot.render();
  
// ▼ スクロール：要求があれば「今日のAM」へ、そうでなければ「1日AM」
if (opts.scrollToToday) {
  const base = todayJST();
  const d = base.getDate();                     // 1..31
  const amCol = 1 + 2 * (d - 1);                // 1列目=1日AM → 2列ずつ進む
  const col = Math.min(amCol, colHeaders.length - 1);
  hot.addHookOnce('afterRender', () => {
    scrollColumnToLeft(hot, container, col);
  });
  // ★ フック直後に再レンダで必ず afterRender を発火
  hot.render();
} else {
  // 他タブ：常に「1日AM(=col 1)」へ
  hot.addHookOnce('afterRender', () => {
    scrollColumnToLeft(hot, container, 1);
  });
  hot.render(); // ★ 同上
}
  // マウスホイール横変換（セル選択中のみ有効）
  enableHorizontalWheel(container, hot);
}


    // ====== スケジュール：整形・表示（既存） ======
    function normalizeSchedules(json) {
      const arr0 = Array.isArray(json) ? json : (json?.items || json?.data || json?.schedules || null);
      if (arr0) {
        return arr0.map(x => {
          const pick = (obj, keys) => {
            for (const k of keys) {
              if (obj[k] != null) return obj[k];
              const lk = Object.keys(obj).find(t => t.toLowerCase() === k.toLowerCase());
              if (lk && obj[lk] != null) return obj[lk];
            }
            return undefined;
          };
          const title = pick(x, ['title','summary','name','subject']) ?? '';
          const date  = pick(x, ['date','day','dt']);
          const start = pick(x, ['start','start_at','startAt','start_time','startTime','from']) || date;
          const end   = pick(x, ['end','end_at','endAt','end_time','endTime','to']);
          const location = pick(x, ['location','place','where']) || '';
          const note = pick(x, ['note','notes','memo','description']) || '';

          const toDate = v => {
            if (!v) return null;
            if (/^\d{4}-\d{2}$/.test(v)) return new Date(v + '-01T00:00:00+09:00');
            if (/^\d{4}-\d{2}-\d{2}$/.test(v)) return new Date(v + 'T00:00:00+09:00');
            const n = Number(v);
            if (!Number.isNaN(n) && String(v).length >= 10) return new Date(n);
            const d = new Date(v);
            return Number.isNaN(d.getTime()) ? null : d;
          };

          const dDate  = toDate(date);
          const dStart = toDate(start) || dDate;
          const dEnd   = toDate(end);

          return {
            raw: x,
            title: String(title || '(無題)'),
            start: dStart,
            end: dEnd,
            baseDate: dDate || dStart || null,
            location,
            note
          };
        }).filter(x => x.baseDate);
      }

      if (json && Array.isArray(json.rows)) {
        const normDay = (s) => (String(s || '').trim().slice(0, 10));
        const daysFromRows = (() => {
          const set = new Set();
          for (const row of json.rows) {
            const cells = row?.cells || {};
            for (const k of Object.keys(cells)) set.add(normDay(k));
          }
          return Array.from(set).sort();
        })();
        const days = Array.isArray(json.days) && json.days.length ? json.days.map(normDay) : daysFromRows;

        const items = [];
        for (const row of json.rows) {
          const emp = row.employee_name || row.name || '（未割当）';
          const cells = row.cells || {};
          for (const k of Object.keys(cells)) {
            const d = normDay(k);
            if (!d) continue;
            const cell = cells[k] || {};
            const toTitle = v => (v == null ? '' : String(v).trim());
            const titles = [toTitle(cell.am), toTitle(cell.pm)].filter(t => t !== '');
            if (titles.length === 0) continue;

            items.push({
              raw: { ...row, date: d, cell },
              employee_name: emp,
              title: titles.join('\n'),
              start: new Date(`${d}T00:00:00`),
              end: null,
              baseDate: new Date(`${d}T00:00:00`),
              location: '',
              note: ''
            });
          }
        }
        return items;
      }
      return [];
    }

    function fmtDate(d) {
      if (!d) return '';
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const da = String(d.getDate()).padStart(2,'0');
      const wd = '日月火水木金土'[d.getDay()];
      return `${y}-${m}-${da}（${wd}）`;
    }
    function fmtTime(d) {
      if (!d) return '';
      const hh = String(d.getHours()).padStart(2,'0');
      const mm = String(d.getMinutes()).padStart(2,'0');
      return `${hh}:${mm}`;
    }

    function filterByMonth(items, ym) {
      const [y,m] = ym.split('-').map(Number);
      return items.filter(x => {
        const d = x.baseDate;
        return d && d.getFullYear() === y && (d.getMonth()+1) === m;
      });
    }

    function renderList(items, mount) {
      if (!items.length) { mount.innerHTML = '<p>該当なし</p>'; return; }
      const groups = new Map();
      for (const it of items) {
        const k = fmtDate(it.baseDate);
        if (!groups.has(k)) groups.set(k, []);
        groups.get(k).push(it);
      }
      for (const arr of groups.values()) {
        arr.sort((a,b) => (a.start?.getTime()||0) - (b.start?.getTime()||0)
          || a.title.localeCompare(b.title,'ja'));
      }
      let html = '';
      for (const [day, arr] of groups) {
        html += `<h3 style="margin:12px 0 6px">${day}</h3>`;
        html += `<ul style="margin:0 0 12px 16px;padding:0">`;
        for (const it of arr) {
          const timePart = it.start ? (it.end ? `${fmtTime(it.start)}–${fmtTime(it.end)}` : `${fmtTime(it.start)}`) : '';
          const loc = it.location ? ` <span style="color:#666">＠${escapeHtml(it.location)}</span>` : '';
          const note = it.note ? `<div style="color:#666;font-size:.9em;white-space:pre-wrap">${escapeHtml(it.note)}</div>` : '';
          html += `<li style="margin:4px 0">
            <strong>${escapeHtml(it.title)}</strong> ${timePart}${loc}
            ${note}
          </li>`;
        }
        html += `</ul>`;
      }
      mount.innerHTML = html;
    }

    function escapeHtml(s){ return String(s)
      .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    function renderSchedules(json, ym) {
      const itemsAll = normalizeSchedules(json);
      const items = filterByMonth(itemsAll, ym);
      const listEl = document.getElementById('sched-list');
      const sumEl = document.getElementById('sched-summary');

      sumEl.textContent = `${ym} の予定: ${items.length}件（取得総数: ${itemsAll.length}件）`;
      renderList(items, listEl);
    }
  </script>
</body>
</html>
