
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>éŸ³å£°å…¥åŠ›ï¼ˆiOSå¯¾å¿œï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://unpkg.com/wanakana"></script>
  <style>
    #voiceControlBar {
      position: fixed;
      bottom: 15vh;
      width: 100vw;
      background: #e0ffff;
      padding: 20px;
      font-size: 24px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 999;
    }
    #voiceLogPanel {
      position: fixed;
      left: 0;
      bottom: 0;
      width: 100vw;
      max-height: 15vh;
      overflow-y: auto;
      background: #f0f0f0;
      padding: 10px;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <h2>iOSå¯¾å¿œ éŸ³å£°å…¥åŠ›</h2>

  <div id="voiceControlBar">
    <input id="voiceInputText" type="text" placeholder="ã“ã“ã«éŸ³å£°å…¥åŠ›ã—ã¦ãã ã•ã„" style="flex: 1; font-size: 20px; margin-right: 10px;">
    <button onclick="processVoiceInput()" style="font-size: 20px;">âœ… ç¢ºå®š</button>
  </div>

  <div id="voiceLogPanel">
    <h4>ğŸ“ å…¥åŠ›ãƒ­ã‚°</h4>
    <ul id="voiceLogList"></ul>
  </div>

  <script>
    function toHiragana(inputText) {
      return wanakana.toHiragana(inputText, { passRomaji: true });
    }

    function processVoiceInput() {
      const input = document.getElementById("voiceInputText").value;
      if (!input.trim()) return;
      addToVoiceLog(input);
      const parsed = parseSpecialInput(input);
      if (parsed) {
        alert("è§£ææˆåŠŸ:\n" + JSON.stringify(parsed, null, 2));
      } else {
        alert("èªè­˜ã§ãã¾ã›ã‚“ã§ã—ãŸ");
      }
      document.getElementById("voiceInputText").value = "";
    }

    function addToVoiceLog(text) {
      const li = document.createElement("li");
      li.textContent = text;
      document.getElementById("voiceLogList").appendChild(li);
    }

    function parseSpecialInput(inputText) {
      const hiragana = toHiragana(inputText);
      const modeWords = {
        "ã‚ã‚‚": "overwrite",
        "ãƒ¡ãƒ¢": "overwrite",
        "ã“ã†ã—ã‚“ã”": "content_overwrite",
        "ã¡ã‡ã‚“ã˜": "content_overwrite",
        "ãƒã‚§ãƒ³ã‚¸": "content_overwrite",
        "ãã‚Šã‚": "clear",
        "ã‚¯ãƒªã‚¢": "clear"
      };

      const delimiters = ["ã°ã—ã‚‡", "å ´æ‰€", "ãƒã‚·ãƒ§"];
      let delimiterUsed = null;
      for (const d of delimiters) {
        if (hiragana.includes(d)) {
          delimiterUsed = d;
          break;
        }
      }
      if (!delimiterUsed) return null;

      const [parentPart, rest] = hiragana.split(delimiterUsed);
      const pattern = /(.*?)(ã‚ã‚‚|ãƒ¡ãƒ¢|ã“ã†ã—ã‚“ã”|ã¡ã‡ã‚“ã˜|ãƒã‚§ãƒ³ã‚¸|ãã‚Šã‚|ã‚¯ãƒªã‚¢)([0-9ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹ã€‡]*)$/;
      const modeMatch = rest.match(pattern);
      if (!modeMatch) return null;

      const childText = modeMatch[1];
      const modeRaw = modeMatch[2];
      const numberRaw = modeMatch[3];

      const mode = modeWords[modeRaw];
      const amount = mode === "clear" || mode === "content_overwrite" ? 0 : convertToNumber(numberRaw);

      return {
        parent: parentPart,
        child: childText,
        mode: mode,
        amount: amount
      };
    }

    function convertToNumber(raw) {
      const str = raw
        .replace(/ã€‡/g, "0")
        .replace(/ä¸€/g, "1")
        .replace(/äºŒ/g, "2")
        .replace(/ä¸‰/g, "3")
        .replace(/å››/g, "4")
        .replace(/äº”/g, "5")
        .replace(/å…­/g, "6")
        .replace(/ä¸ƒ/g, "7")
        .replace(/å…«/g, "8")
        .replace(/ä¹/g, "9")
        .replace(/[^\d.]/g, "");
      const num = parseFloat(str);
      return isNaN(num) ? 0 : num;
    }
  </script>
</body>
</html>
